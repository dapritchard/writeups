---
title: dplyr Overview Part 2
author: David Pritchard
date: April 7, 2020
output:
  revealjs::revealjs_presentation:
    theme: serif
    # theme: simple
    center: false
---

<style>
  .reveal section p {
    display: inline-block;
    font-size: 0.7em;
    line-height: 1.2em;
    vertical-align: top;
    text-align: left;
  }
  .reveal h1 {
    font-size: 1.8em;
  }
  .reveal h2 {
    font-size: 1.2em;
  }
  .reveal ul {
    font-size: 0.7em;
  }
  .reveal ul ul {
    font-size: 0.9em;
    <!-- line-height: 350%; -->
    <!-- margin-bottom: 45px; -->
  }
  .reveal li {
    line-height: 100%;
    margin-bottom: 15px;
    margin-top: 00px;
  }
  .reveal li li {
    margin-top: 10px;
    <!-- margin-bottom: 10px; -->
  }
</style>


```{r, echo = FALSE}
options(tibble.print_max = 6)
options(tibble.print_min = 6)

knitr::opts_chunk$set(collapse = TRUE)

# def.chunk.hook  <- knitr::knit_hooks$get("chunk")
# knitr::knit_hooks$set(chunk = function(x, options) {
#   x <- def.chunk.hook(x, options)
#   ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
# })
# knitr::opts_chunk$set(size = "small")
```


# Motivation

## Historical perspective

Metaprogramming

  * The S language bears a strong similarity to Scheme[^scheme] (with some
    notable exceptions).  <!-- paraphrased from Ihaka R A Language for Data
    Analysis and Graphics -->
  * One particular language feature that is fundamental to Lisp is a form of
    metaprogramming in which programs can create or manipulate other programs
    at runtime.  <!-- Scott page 562 -->

[^scheme]: A Lisp dialect created by Guy Steele and Gerald Jay Sussman.




## Historical perspective (cont.)

Metaprogramming

  * One familiar form of metaprogramming that is available in many languages is
    the ability to `eval` text strings.
  * In Lisp there is no syntactical differentiation between code and
    data[^homoiconicity], so metaprogramming involves direct manipulating of the
    program.
  * S provides an interface to manipulate the data structure (more upcoming on
    this) that statements are stored in order to provide similar functionality.
    <!--
    http://www.sumsar.net/blog/2014/11/tidbits-from-books-that-defined-s-and-r/
    -->

[^homoiconicity]: This property is sometimes referred to as _homoiconicity_,
however there is some disagreement about the usage of the term, see
e.g. https://www.expressionsofchange.org/dont-say-homoiconic/.




## Abstract syntax trees

Statements in R and programming languages in general are naturally represented
by the interpreter as a tree-like data structure called an **abstract syntax
tree** (AST).

  * The read portion of the read-eval-print loop constructs the AST.
  * The R interpreter (in contrast to S) is implemented as a Lisp.
    * R's infix operators are translated to Polish notation (i.e. operators
      precede their arguments, and consequently is also known as prefix
      notation).
    * So, for example, `x + y` is translated internally to `"+"(x, y)`
    * Even structures like if-else if-else and for loops that are represented as
      syntax in many languages are mapped to prefix functions.




## Abstract syntax tree example

Consider the AST constructed from the expression `1 + 2 * 3`.  The AST has the
following form:

  * The result of evaluating `+` on `1` and
    * The result of evaluating `*` on `2` and `3`

The `lobstr::ast` function provides a visual representation of an AST
constructed from an R statement.

```{r}
library(lobstr)
ast(1 + 2 * 3)
```

<!-- You can construct a data structure representing an AST by using
e.g. `quote(1 + --> <!-- 2 * 3)` (more on this later). -->




## Abstract syntax tree components

There are four types of data structures that can be found in an AST, which are
collectively referred to as **expressions** by Wickham, Henry, etc.: <!--
Section 18.3, Advanced R -->

  * **Call**: A function call.
  * **Constant:** either `NULL` or a length-1 atomic vector.
  * **Symbol:** the name of an object like e.g. `x`.  (These are synonymously
    known in R as **name**s.)
  * **Pairlist**: a list-like object most often used to store a function's
    formal arguments.




## A note about terminology:

Hadley Wickham and Lionel Henry have co-opted the term _expression_ mean any of
the data structures found in an AST, however the R Language Definition does not
use this terminology.

  * The term _expression_ is used to mean any of the data structures found in an
    AST
  * R has an `expression` object, which Wickham and Henry refer to as
    _expression vectors_.
  * In the general computer science literature, an expression is a combination
    of one or more constants, variables, operators, and functions that the
    programming language interprets.  The R Language definition refers to these
    as statements to disambiguate from expression vectors.

In this document, we will follow the convention proposed by Wickham and Henry.




## Language objects

R has also has related concepts of language objects and language data types, so
let's get these terminologies straight as well.

  * A language object is an umbrella term referring to an object that is either
    a call, expression, or symbol.
    * `is.language` returns `TRUE` for any one of these three data types, and
      `FALSE` otherwise.
    * `typeof` may return `language` (see below), `expression`, or `symbol`,
      depending on the object type.
  * Confusingly, R also has a language sexp[^sexp] which is the data type used
    to represent calls.
    * `is.language` returns `TRUE`, `is.call` returns `TRUE`, `typeof` returns
      `language`, and `mode` returns `call`.

If you think this is poorly-chosen vocabulary, then you are not alone in this
opinion.

[^sexp]: A sexp is the vernacular used to refer to a symbolic expression, and is
    also referred to as an s-expression or a sexpr.  Sexps are the foundational
    data type that are available to the R language.  <!-- Section 1.1, R
    Internals -->




# Obtaining R expressions

## AST elements: symbols

As previously mentioned, constants are either `NULL` or a length-1 atomic
vector such as `TRUE`, 1L, 2.5, or "mystring".

  * These types each have a special read syntax that the parser recognizes.






## Expression vectors

An expression vector is an ordered collection of R statements represented as
ASTs.  You can obtain an expression vector using e.g. `expression` and `parse`.

```{r}
# `a` and `b` are equivalent up to the attributes
a <- expression(x + y, z)
b <- parse(text = "x + y; z")
is.expression(a)
is.expression(b)
all.equal(a, b, check.attributes = FALSE)
a
b
```




## Expressions

You can use `eval` to evaluate an expression or expression vector.
```{r}
eval(parse(text = "x <- 2; x * x"))
eval(1)
eval(quote(mean(1L:11L)))
eval(quote(x))
```

It is interesting to note that in most languages, `eval` takes a string as
input.

  * Since the elements of the AST are exposed to the user, `eval` operates on
    them directly.




## Examples of common AST elements

```{r}
identical(quote(1), 1)  # by definition, constants are self-evaluating
is.language(1)

b <- quote(x)
is.language(b); is.symbol(b)

c <- quote(1 + 2 * 3)
is.language(c); is.call(c)
```




<!-- ## Language objects (cont.) -->

<!-- Some notes about language objects: -->

<!--   * Hadley Wickham and Lionel Henry use the term _expression_ to mean any of the -->
<!--     data structures found in an AST, and refer to the `expression` object as -->
<!--     _expression vectors_.  **We will follow suit.** -->
<!--   * Hadley suggests using lists of calls instead of expression vectors in most -->
<!--     cases. -->




## Manipulating calls

You can access and modify elements of a call using a list-like interface.

```{r, collapse = TRUE}
z <- quote(1 + 2 * 3)

z[[1L]]
is.symbol(z[[1L]])  # synonymous with `is.name`

z[[2L]]
is.numeric(z[[2L]])

z[[3L]]
is.call(z[[3L]])
```




## Manipulating calls (cont.)


```{r, collapse = TRUE}
z
ast(1 + 2 * 3)

length(z)
z[[1L]] <- as.name("-")  # synonymous with `as.symbol`
z[[2L]] <- quote(6 / 2)
z
```




## Example parsing input

```{r}
xdist = "x = rnorm(1,y,1)
y = rnorm(1,z,1)
z = rnorm(1,5,1)"
```




## `parse_heir_minilang` definition

```r
parse_hier_minilang <- function(hierarchical) {
  comb_hier <- function(outerdist, innerdist) {
    out <- paste(
      strsplit(outerdist[2L], innerdist[1L])[[1L]],
      collapse = innerdist[2L]
    )
    c(outerdist[[1L]], out)
  }
  distexpr <- strsplit(
    strsplit(hierarchical, "\n")[[1L]],
    " *= *"
  )
  distcomb <- Reduce(comb_hier, distexpr)
  distcomb[[2L]]
}
heir_dist_expr <- parse_hier_minilang(xdist)
n_sims <- replicate(1000L, eval(parse(text = heir_dist_expr)))
```




# Promises and lazy evaluation

## Lazy evaluation in R

The S language stipulates that the arguments of a function call are not
evaluated until they are needed.

  * A form of _lazy evaluation_.
  * Implemented in R by assigning each formal argument name a special object of
    type _promise_.




## Promises

The _promise_ type has the following characteristics.

  * Contains three elements:
    * The expression provided as input to the argument in the function call.
    * The environment (i.e. the scope) in which to evaluate the expression.
    * The value obtained by evaluating the expression (initially empty).
  * The value of the promise is calculated the first time it is needed, and not
    before.  After calculation the value is stored.
  * Subsequent uses of the variable use the stored value.




## Extracting the promise expression

The `substitute` function creates an expression in a manner similar to `quote`.

  * However, `substitute` performs the added step of replacing symbols that
    it finds in the expression that exist in the specified environment.
    * The environment is specified through the formal argument `env` (default is
      the current environment).
    * If a symbol in the expression has a binding in the specified environment,
      then it replaces the symbol with the value bound to the symbol in the
      environment.




## Extracting the promise expression (cont.)


```{r}
print_input <- function(x) {
  substitute(x)
}
print_input(1 + 2 * 3)
```




<!-- promises page 457 Software for Data Analysis ----------------------------->

<!-- R implements the grammer of S, with a few extensions --------------------->

<!-- http://www.sumsar.net/blog/2014/11/tidbits-from-books-that-defined-s-and-r/ -->

<!-- https://www.stat.auckland.ac.nz/~ihaka/downloads/Interface98.pdf -->

<!-- https://rpubs.com/maechler/R_language_objs -->
