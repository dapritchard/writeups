---
title: dplyr Overview Part 2
author: David Pritchard
date: April 7, 2020
output:
  revealjs::revealjs_presentation:
    theme: serif
    # theme: simple
    center: false
---

<style>
  .reveal section p {
    display: inline-block;
    font-size: 0.7em;
    line-height: 1.2em;
    vertical-align: top;
    text-align: left;
  }
  .reveal h1 {
    font-size: 1.8em;
    color: darkblue;
  }
  .reveal h2 {
    font-size: 1.2em;
  }
  .reveal ul {
    font-size: 0.7em;
  }
  .reveal ul ul {
    font-size: 0.9em;
    <!-- line-height: 350%; -->
    <!-- margin-bottom: 45px; -->
  }
  .reveal li {
    line-height: 100%;
    margin-bottom: 15px;
    margin-top: 00px;
  }
  .reveal li li {
    margin-top: 10px;
    <!-- margin-bottom: 10px; -->
  }
</style>


```{r, echo = FALSE}
options(tibble.print_max = 6)
options(tibble.print_min = 6)

knitr::opts_chunk$set(collapse = TRUE)
```


# Motivation

## Historical perspective

Metaprogramming

  * The S language bears a strong similarity to Scheme[^scheme] (with some
    notable exceptions).  <!-- paraphrased from Ihaka R A Language for Data
    Analysis and Graphics -->
  * One particular language feature that is fundamental to Lisp is a form of
    metaprogramming in which programs can create or manipulate other programs
    at runtime.  <!-- Scott page 562 -->

[^scheme]: A Lisp dialect created by Guy Steele and Gerald Jay Sussman.




## Historical perspective (cont.)

Metaprogramming

  * One familiar form of metaprogramming that is available in many languages is
    the ability to `eval` text strings.
  * In Lisp there is no syntactical differentiation between code and
    data[^homoiconicity], so metaprogramming involves direct manipulating of the
    program.
  * S provides an interface to manipulate the data structure (more upcoming on
    this) that statements are stored in order to provide similar functionality.
    <!--
    http://www.sumsar.net/blog/2014/11/tidbits-from-books-that-defined-s-and-r/
    -->

[^homoiconicity]: This property is sometimes referred to as _homoiconicity_,
however there is some disagreement about the usage of the term, see
e.g. https://www.expressionsofchange.org/dont-say-homoiconic/.




## Abstract syntax trees

Expressions in programming languages are naturally represented by the
interpreter as a tree-like data structure called an **abstract syntax tree**
(AST).

  * The read portion of the read-eval-print loop constructs the AST.
  * The R interpreter (in contrast to S) is implemented as a Lisp.
    * R's infix operators are translated to Polish notation (i.e. operators
      precede their arguments, and consequently is also known as prefix
      notation).
    * So, for example, `x + y` is translated internally to `"+"(x, y)`
    * Even structures like if-else if-else and for loops that are represented as
      syntax in many languages are mapped to prefix functions.




## Abstract syntax tree example

Consider the AST constructed from the expression `1 + 2 * 3`.  The AST has the
following form:

  * The result of evaluating `+` on `1` and
    * The result of evaluating `*` on `2` and `3`

The `lobstr::ast` function provides a visual representation of an AST
constructed from an R statement.

```{r}
library(lobstr)
ast(1 + 2 * 3)
```




## Abstract syntax tree components

There are four types of data structures that can be found in an AST, which are
collectively referred to as _expressions_ by Wickham, Henry, etc.: <!--
Section 18.3, Advanced R -->

  * **Call**: A function call.
  * **Constant:** either `NULL` or a length-1 atomic vector.
  * **Symbol:** the name of an object like e.g. `x`.  (These are synonymously
    known in R as **name**s.)
  * **Pairlist**: a list-like object most often used to store a function's
    formal arguments.




## A note about terminology:

Hadley Wickham and Lionel Henry have co-opted the term _expression_ mean any of
the data structures found in an AST, however the R Language Definition does not
use this terminology.

  * The term _expression_ is used by Wickham and Henry to mean any of the data
    structures found in an AST
  * R has an `expression` data type, which Wickham and Henry refer to as
    _expression vectors_.
  * In the general computer science literature, an expression is a combination
    of one or more constants, variables, operators, and functions that the
    programming language interprets.  The R Language definition refers to these
    as _statements_ to disambiguate from expression vectors.

In this document, we will follow the convention proposed by Wickham and Henry.




## Language objects

R has also has related concepts of language objects and language data types, so
let's get these terminologies straight as well.

  * A language object is an umbrella term referring to an object that is either
    a call, expression, or symbol.
    * `is.language` returns `TRUE` for any one of these three data types, and
      `FALSE` otherwise.
    * `typeof` may return `language` (see below), `expression`, or `symbol`,
      depending on the object type.
  * Confusingly, R also has a language data type which is the data type used to
    represent calls.
    * `is.language` returns `TRUE`, `is.call` returns `TRUE`, `typeof` returns
      `language`, and `mode` returns `call`.

If you think this is unfortunate vocabulary, then you are not alone.

<!-- [^sexp]: A sexp is the vernacular used to refer to a symbolic expression, and is -->
<!--     also referred to as an s-expression or a sexpr.  Sexps are the foundational -->
<!--     data type that are available to the R language.  <\!-- Section 1.1, R -->
<!--     Internals -\-> -->




# ------------------------------------------------------------------------------

# Capturing and evaluating expressions

## Typical expression evaluation

One of the tasks that is performed by an interpreter (indeed, the interpreter's
raison d'Ãªtre) such as R is to evaluate expressions (i.e. the 'eval' stage of
the read-eval-print loop).

  * Evaluating an expression produces a value.
  * Expressions may consist of sub-expressions (e.g. `f(1, g(7, 2))`).
  * Sub-expressions are recursively evaluated until they cannot be simplified
    any further (at which point the expression is said to be in _normal form_).




## Quoting code

In order to be able to obtain a data structure representing an unevaluated
expression or sub-expression, Lisp-like languages such as R provide a mechanism
called _quotation_, which is a function that simply returns its input unmolested
by the evaluator.  R provides several interfaces for quotation.

  * The `quote` function is perhaps the most fundamental expression of
    quotation in R, but as we will see there are many others.

```{r}
quote(1 + 2 * 3)
```

Note that it is common to refer to "quoting" a section of source code to mean
placing single or double quotation marks around that code, but this is an
entirely separate meaning of the word "quoting."




## Expression vectors

Expression vectors are a data type providing an ordered collection of
expressions.  The functions `expression` and `parse` each return expression
vectors and can be used to capture expressions.

  * The `expression` function performs quotation on each of a sequence of
    comma-separated expressions.
  * The `parse` function parses a sequence of statements either from a source
    file or a text string.

```{r}
# `a` and `b` are equivalent up to the attributes
a <- expression(x + y, z)
b <- parse(text = "x + y; z")
all.equal(a, b, check.attributes = FALSE)
typeof(a)
a
```




## Evaluating expressions

You can use `eval` to evaluate an expression or expression vector.
```{r}
eval(parse(text = "x <- 2; x * x"))
eval(1)
eval(quote(mean(seq(1, 101))))
eval(quote(x))
```

It is interesting to note that in most languages, `eval` takes a string as
input.

  * Since the elements of the AST are exposed to the user, `eval` operates on
    them directly.




# ------------------------------------------------------------------------------

# Expression elements

## Expression elements: constants

As previously mentioned, constants are either `NULL` or a length-1 atomic vector
such as `TRUE`, `1L`, `2.5`, `1i`, or `"mystring"`.

  * These types each have a special read syntax that the parser recognizes,
    creating an object with the specific type.
  * The defining property of constants in general is that they are _self
    evaluating_, meaning that the result of evaluating the constant is the
    constant itself.

```{r}
# expression vectors can be treated as a list-like object
sapply(expression(TRUE, 1L, 2.5, 1i, "mystring"), typeof)
identical(2.5, quote(2.5))
```




## Expression elements: symbols

A symbol represents the name of an object, such as `x` in the expression `x +
1`.

  * When the R evaluator evaluates a symbol, it replaces it with the value that
    is bound to the appropriate variable of the same name
  * The variable is selected according to the lexical scoping rules.

```{r}
quote(x)
typeof(quote(x))
identical(quote(x), as.symbol("x"))
identical("x", as.character(quote(x)))
```




## Expression elements: pairlists

Pairlists are most often encountered as the data structure representing the formal
arguments to a function.

  * Pairlists are implemented using a linked list, but can be treated just like
    a regular list.

```{r}
lobstr::ast(function(x = 2, y = 3) 22)
f <- quote(function(x = 2, y = 3) 22)
f[[2L]]
typeof(f[[2L]])
```




## Expression elements: calls

A call is a unevaluated function call.

```{r}
lobstr::ast(f(1, g(7, 2)))
x = quote(f(1, g(7, 2)))
is.language(x)
is.call(x)
typeof(x)
mode(x)
```




## Constructing calls

TODO




## Formulas: a most useful type of call

TODO




# Manipulating expressions

```{r}
# TODO
```




## Quasiquotation

TODO
<!-- quote, substitute -->




## Constructing calls

<!-- call -->




<!-- ## Examples of common AST elements -->

<!-- ```{r} -->
<!-- identical(quote(1), 1)  # by definition, constants are self-evaluating -->
<!-- is.language(1) -->

<!-- b <- quote(x) -->
<!-- is.language(b); is.symbol(b) -->

<!-- c <- quote(1 + 2 * 3) -->
<!-- is.language(c); is.call(c) -->
<!-- ``` -->




<!-- ## Language objects (cont.) -->

<!-- Some notes about language objects: -->

<!--   * Hadley Wickham and Lionel Henry use the term _expression_ to mean any of the -->
<!--     data structures found in an AST, and refer to the `expression` object as -->
<!--     _expression vectors_.  **We will follow suit.** -->
<!--   * Hadley suggests using lists of calls instead of expression vectors in most -->
<!--     cases. -->




## Manipulating calls

You can access and modify elements of a call using a list-like interface.

```{r, collapse = TRUE}
z <- quote(1 + 2 * 3)

z[[1L]]
is.symbol(z[[1L]])  # synonymous with `is.name`

z[[2L]]
is.numeric(z[[2L]])

z[[3L]]
is.call(z[[3L]])
```




## Manipulating calls (cont.)


```{r, collapse = TRUE}
z
ast(1 + 2 * 3)

length(z)
z[[1L]] <- as.name("-")  # synonymous with `as.symbol`
z[[2L]] <- quote(6 / 2)
z
```




## Example parsing input

```{r}
xdist = "x = rnorm(1,y,1)
y = rnorm(1,z,1)
z = rnorm(1,5,1)"
```




## `parse_heir_minilang` definition

```r
parse_hier_minilang <- function(hierarchical) {
  comb_hier <- function(outerdist, innerdist) {
    out <- paste(
      strsplit(outerdist[2L], innerdist[1L])[[1L]],
      collapse = innerdist[2L]
    )
    c(outerdist[[1L]], out)
  }
  distexpr <- strsplit(
    strsplit(hierarchical, "\n")[[1L]],
    " *= *"
  )
  distcomb <- Reduce(comb_hier, distexpr)
  distcomb[[2L]]
}
heir_dist_expr <- parse_hier_minilang(xdist)
n_sims <- replicate(1000L, eval(parse(text = heir_dist_expr)))
```




# Promises and lazy evaluation

## Lazy evaluation in R

The S language stipulates that the arguments of a function call are not
evaluated until they are needed.

  * A form of _lazy evaluation_.
  * Implemented in R by assigning each formal argument name a special object of
    type _promise_.




## Promises

The _promise_ type has the following characteristics.

  * Contains three elements:
    * The expression provided as input to the argument in the function call.
    * The environment (i.e. the scope) in which to evaluate the expression.
    * The value obtained by evaluating the expression (initially empty).
  * The value of the promise is calculated the first time it is needed, and not
    before.  After calculation the value is stored.
  * Subsequent uses of the variable use the stored value.




## Extracting the promise expression

The `substitute` function creates an expression in a manner similar to `quote`.

  * However, `substitute` performs the added step of replacing symbols that
    it finds in the expression that exist in the specified environment.
    * The environment is specified through the formal argument `env` (default is
      the current environment).
    * If a symbol in the expression has a binding in the specified environment,
      then it replaces the symbol with the value bound to the symbol in the
      environment.




## Extracting the promise expression (cont.)


```{r}
print_input <- function(x) {
  substitute(x)
}
print_input(1 + 2 * 3)
```




<!-- promises page 457 Software for Data Analysis ----------------------------->

<!-- R implements the grammer of S, with a few extensions --------------------->

<!-- http://www.sumsar.net/blog/2014/11/tidbits-from-books-that-defined-s-and-r/ -->

<!-- https://www.stat.auckland.ac.nz/~ihaka/downloads/Interface98.pdf -->

<!-- https://rpubs.com/maechler/R_language_objs -->
